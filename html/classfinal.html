<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Project c++: Référence de la classe final</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Project c++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Projet c ++ 2017 sur les formes</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Généré par Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Liste&#160;des&#160;classes</span></a></li>
      <li><a href="classes.html"><span>Index&#160;des&#160;classes</span></a></li>
      <li><a href="inherits.html"><span>Hiérarchie&#160;des&#160;classes</span></a></li>
      <li><a href="functions.html"><span>Membres&#160;de&#160;classe</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classfinal.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#friends">Amis</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe final</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="final" -->
<p><code>#include &lt;<a class="el" href="ez-draw_09_09_8hpp_source.html">ez-draw++.hpp</a>&gt;</code></p>

<p><a href="classfinal-members.html">Liste de tous les membres</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a137551852752fb124ecd6ff218efb578">EZImage</a> (int width, int height)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a080cf158fb744b40782be2e181623129"></a><!-- doxytag: member="final::EZImage" ref="a080cf158fb744b40782be2e181623129" args="(const EZImage &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a080cf158fb744b40782be2e181623129">EZImage</a> (const EZImage &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a99379c6a805ce5debe2a9a15ea831d9b">EZImage</a> (const char *filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0b6a20b0a530f687614b86caeca883"></a><!-- doxytag: member="final::~EZImage" ref="aed0b6a20b0a530f687614b86caeca883" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#aed0b6a20b0a530f687614b86caeca883">~EZImage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur de la classe EZImage. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdfbd3621e46c42155117eaaf2ffee32"></a><!-- doxytag: member="final::getWidth" ref="acdfbd3621e46c42155117eaaf2ffee32" args="() const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#acdfbd3621e46c42155117eaaf2ffee32">getWidth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur pour la largeur actuelle de l'image. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3055b56261e8a0843aff0432862197f"></a><!-- doxytag: member="final::getHeight" ref="ab3055b56261e8a0843aff0432862197f" args="() const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#ab3055b56261e8a0843aff0432862197f">getHeight</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur pour la hauteur actuelle de l'image. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a2fe89de306240059536ee07dc1f8a29e">setAlpha</a> (bool has_alpha)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1c8499d07d0dce934eb01430622319"></a><!-- doxytag: member="final::getAlpha" ref="a1b1c8499d07d0dce934eb01430622319" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a1b1c8499d07d0dce934eb01430622319">getAlpha</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cet accesseur permet de savoir si l'image contient de la transparence (true) ou pas (false). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a9d817ae0dca397d0a1315ab12b38cb11">setOpacity</a> (int opacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a5fdf8de88569b13da03b0bfac2db0f84">getOpacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_z_pixel.html">EZPixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#ab41a112c56debb061310533939ced93d">getPixel</a> (unsigned int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aacab1e15e82c5976bfb476ddfe145263c">x</a>, unsigned int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aae1f9fdb8b786c63efc4ce44eeacd17f2">y</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a3a610d4dfd7c4d2ad42d6b25e5ff47ab">paint</a> (<a class="el" href="class_e_z_window.html">EZWindow</a> &amp;win, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aacab1e15e82c5976bfb476ddfe145263c">x</a>, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aae1f9fdb8b786c63efc4ce44eeacd17f2">y</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#aebe22646f553cd099aee45754deace05">paintSubimage</a> (<a class="el" href="class_e_z_window.html">EZWindow</a> &amp;win, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aacab1e15e82c5976bfb476ddfe145263c">x</a>, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aae1f9fdb8b786c63efc4ce44eeacd17f2">y</a>, int src_x, int src_y, int width, int height) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60ff6c7afa439bb21a9d320d3794341"></a><!-- doxytag: member="final::print" ref="ab60ff6c7afa439bb21a9d320d3794341" args="(int src_x, int src_y, int w, int h) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#ab60ff6c7afa439bb21a9d320d3794341">print</a> (int src_x, int src_y, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aac2ee9060499a346927bbe8470a68e274">w</a>, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aa83684c9789c44b5b6edca6ae4ae1eeb5">h</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche une région rectangulaire d’une image dans le terminal. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a64cd7f6b066b7814e381391019eaee04">fillRGBA</a> (<a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a> red, <a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a> green, <a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a> blue, <a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a> alpha)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a62fd392ac1d76972e50f3d4db7cda453">blend</a> (const EZImage &amp;src, int dst_x, int dst_y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#aff8eb8cf7ac603075fae85a4fb7b874e">blendSubimage</a> (const EZImage &amp;src, int dst_x, int dst_y, int src_x, int src_y, int width, int height)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EZImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#ac16e63b805e9f77eb77dd953893e308f">extract</a> (int src_x, int src_y, int width, int height) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EZImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a454235329a4b58a9fd2ba33afacf3ba0">verticalSymmetry</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EZImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a2c2955511ddc9aa8695e3e74281868a7">horizontalSymmetry</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EZImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a2f4fe23e6f1a1283c38b8b5e7a93dbc6">scale</a> (double factor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EZImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a404f95ce3eca200baf5c6cfe741888c5">rotate</a> (double theta, int quality) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a9bfac82a791b0bc88094814bd59e204f">rotatePoint</a> (double theta, int src_x, int src_y, int &amp;dst_x, int &amp;dst_y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a7e534ca9d0e4829714be1322f7bb87e0">EZPixmap</a> (const EZImage &amp;image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fa81aea1e90de14ebf108426d30a1ce"></a><!-- doxytag: member="final::~EZPixmap" ref="a5fa81aea1e90de14ebf108426d30a1ce" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a5fa81aea1e90de14ebf108426d30a1ce">~EZPixmap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur de la classe EZPixmap. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a3a610d4dfd7c4d2ad42d6b25e5ff47ab">paint</a> (<a class="el" href="class_e_z_window.html">EZWindow</a> &amp;win, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aacab1e15e82c5976bfb476ddfe145263c">x</a>, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aae1f9fdb8b786c63efc4ce44eeacd17f2">y</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfinal.html#a6556cbdbad6164501ba6a116dd9a0b08">tile</a> (<a class="el" href="class_e_z_window.html">EZWindow</a> &amp;win, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aacab1e15e82c5976bfb476ddfe145263c">x</a>, int <a class="el" href="ez-draw_09_09_8hpp.html#ab4ada4f5b7011a8a08fd77572ddabc1aae1f9fdb8b786c63efc4ce44eeacd17f2">y</a>, int width, int height) const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Amis</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109ee502d92c11d8b86d35f7fecc00e5"></a><!-- doxytag: member="final::EZPixmap" ref="a109ee502d92c11d8b86d35f7fecc00e5" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>EZPixmap</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Description détaillée</h2>
<div class="textblock"><p>La classe EZImage permet de conserver une image en mémoire puis de la tracer à l'écran. Attention, il n'est pas permis de dériver cette classe par héritage.</p>
<p>La classe EZPixmap permet d'améliorer nettement les performances de tracé à l'écran par rapport à la classe EZImage qui est plus générale mais aussi plus lente. L'affichage d'une instance de EZImage nécessite une série de conversions qui sont faites à chaque fois qu'un tracé est réclamé, ce qui peut prendre plusieurs dizaines de millisecondes. Lorsque l'affichage comporte le dessin d'un nombre important de telles images au sein d'une animation, par exemple dans un jeu vidéo, le résultat peut devenir trop saccadé pour être acceptable. La classe EZPixmap permet de figer une image et de la transférer au plus près du matériel graphique (le plus souvent, jusqu'à la mémoire de la carte graphique), ce qui rendra son tracé très nettement plus rapide. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>L'exemple demo++17 permet de tester la vitesse d’affichage, mesurée en fps (pour frame per second) dans une animation. Utiliser les touches + et - pour modifier le nombre de balles, et la touche p pour activer l’utilisation des pixmaps. </dd></dl>
</div><hr/><h2>Documentation des fonctions membres</h2>
<a class="anchor" id="a62fd392ac1d76972e50f3d4db7cda453"></a><!-- doxytag: member="final::blend" ref="a62fd392ac1d76972e50f3d4db7cda453" args="(const EZImage &amp;src, int dst_x, int dst_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a62fd392ac1d76972e50f3d4db7cda453">final::blend</a> </td>
          <td>(</td>
          <td class="paramtype">const EZImage &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Incruste une partie de l'image src dans l'image courante. La région de l’image source src est délimitée par les coordonnées src_x, src_y (coin supérieur gauche) et src_x+w-1, src_y+h-1 (coin inférieur droit). Cette région est incrustée dans l’image destination dst aux coordonnées dst_x, dst_y (coin supérieur gauche) et dst_x+w-1, dst_y+h-1 (coin inférieur droit). Si les coordonnées dépassent les images src ou l'image courante, seule la région commune est incrustée. Si l’image source n’a pas de canal alpha alors les valeurs de la région de src écrasent celle de dst. Dans le cas contraire, les régions sont mélangées par transparence (alpha blending) avec les formules de [<a href="https://fr.wikipedia.org/wiki/Alpha_blending">https://fr.wikipedia.org/wiki/Alpha_blending</a>](Porter et Duff). </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>l'image source de la recopie </td></tr>
    <tr><td class="paramname">dst_x,dst_y</td><td>les coordonnées où le coin supérieur-gauche de l'image src doit arriver dans l'image courante. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff8eb8cf7ac603075fae85a4fb7b874e"></a><!-- doxytag: member="final::blendSubimage" ref="aff8eb8cf7ac603075fae85a4fb7b874e" args="(const EZImage &amp;src, int dst_x, int dst_y, int src_x, int src_y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#aff8eb8cf7ac603075fae85a4fb7b874e">final::blendSubimage</a> </td>
          <td>(</td>
          <td class="paramtype">const EZImage &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Idem à la fonction void EZImage::blend(const EZImage&amp; src, int dst_x, int dst_y) mais où il est possible de n'incruster qu'une sous-partie rectangulaire de l'image src. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>l'image source de la recopie. </td></tr>
    <tr><td class="paramname">dst_x,dst_y</td><td>les coordonnées où le coin supérieur-gauche de l'image src doit arriver dans l'image courante. </td></tr>
    <tr><td class="paramname">src_x,src_y</td><td>les coordonnées dans l'image src du coin supérieur-gauche de la sous-partie à recopier. </td></tr>
    <tr><td class="paramname">width,height</td><td>les dimensions largeur et hauteur de la sous-partie à recopier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac16e63b805e9f77eb77dd953893e308f"></a><!-- doxytag: member="final::extract" ref="ac16e63b805e9f77eb77dd953893e308f" args="(int src_x, int src_y, int width, int height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EZImage* <a class="el" href="classfinal.html#ac16e63b805e9f77eb77dd953893e308f">final::extract</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extrait une partie rectangulaire d'une image existante. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src_x,src_y</td><td>la coordonnée du coin supérieur-gauche du rectangle à copier dans l'image d'origine. </td></tr>
    <tr><td class="paramname">width,height</td><td>la largeur et la hauteur de la zone à copier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Renvoie une nouvelle instance de EZImage allouée dynamiquement (et qui devra être détruite grâce à l'opérateur delete) ou nullptr en cas d’erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a137551852752fb124ecd6ff218efb578"></a><!-- doxytag: member="final::EZImage" ref="a137551852752fb124ecd6ff218efb578" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final::EZImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructeur d'une nouvelle image à partir de ses dimensions. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width,height</td><td>la largeur et la hauteur de l'image voulue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99379c6a805ce5debe2a9a15ea831d9b"></a><!-- doxytag: member="final::EZImage" ref="a99379c6a805ce5debe2a9a15ea831d9b" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final::EZImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructeur à partir d'un fichier d'image qui sera chargé en mémoire à partir du disque dur. Les formats supportés sont : PNG, GIF, BMP, JPEG. Les formats PNG et PMP supportent des degrés variables de transparence. Le format GIF ne permet que de la transparence en tout ou rien. Le format JPEG ne permet pas de représenter la transparence. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>le nom de fichier complet (ou relatif) permettant au programme de trouver le fichier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e534ca9d0e4829714be1322f7bb87e0"></a><!-- doxytag: member="final::EZPixmap" ref="a7e534ca9d0e4829714be1322f7bb87e0" args="(const EZImage &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final::EZPixmap </td>
          <td>(</td>
          <td class="paramtype">const EZImage &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructeur de la classe EZPixmap à partir d'une instance de la classe EZImage. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>L'instance de la classe EZImage à partir de laquelle il faut constuire le EZPixmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Une fois le EZPixmap construit, il n'a plus aucun lien avec l'instance de EZImage qui a servi à sa construction. En particulier, il n'est pas modifié lorsque cette dernière est modifiée. </dd></dl>

</div>
</div>
<a class="anchor" id="a64cd7f6b066b7814e381391019eaee04"></a><!-- doxytag: member="final::fillRGBA" ref="a64cd7f6b066b7814e381391019eaee04" args="(EZuint8 red, EZuint8 green, EZuint8 blue, EZuint8 alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a64cd7f6b066b7814e381391019eaee04">final::fillRGBA</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a>&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ez-draw_09_09_8hpp.html#ad1c21a8c6a39bdb445797fdbb2f5c04f">EZuint8</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remplit l'image courante avec la couleur et le degré de transparence indiqué. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">red,green,blue</td><td>les trois composantes (rouge, verte et bleue), chacune entre 0 et 255, de la couleur à tracer. </td></tr>
    <tr><td class="paramname">alpha</td><td>le degré de transparence, entre 0 (complètement transparent) et 255 (complètement opaque). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fdf8de88569b13da03b0bfac2db0f84"></a><!-- doxytag: member="final::getOpacity" ref="a5fdf8de88569b13da03b0bfac2db0f84" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classfinal.html#a5fdf8de88569b13da03b0bfac2db0f84">final::getOpacity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accesseur pour la valeur de transparence. </p>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>La valeur retournée est entre 0 (complètement transparent) et 255 (complètement opaque). Le détail du principe de calcul de transparence est détaillé dans [<a href="https://fr.wikipedia.org/wiki/Alpha_blending">https://fr.wikipedia.org/wiki/Alpha_blending</a>](cette page Wikipédia). </dd></dl>

</div>
</div>
<a class="anchor" id="ab41a112c56debb061310533939ced93d"></a><!-- doxytag: member="final::getPixel" ref="ab41a112c56debb061310533939ced93d" args="(unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_z_pixel.html">EZPixel</a> <a class="el" href="classfinal.html#ab41a112c56debb061310533939ced93d">final::getPixel</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accesseur pour obtenir un pixel de coordonnées x et y. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Les coordonnées du pixel voulu dans l'image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Une instance de la classe <a class="el" href="class_e_z_pixel.html">EZPixel</a> qui permet de consulter ou modifier les valeurs de composantes de couleur du pixel. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2955511ddc9aa8695e3e74281868a7"></a><!-- doxytag: member="final::horizontalSymmetry" ref="a2c2955511ddc9aa8695e3e74281868a7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EZImage* <a class="el" href="classfinal.html#a2c2955511ddc9aa8695e3e74281868a7">final::horizontalSymmetry</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construit une nouvelle image par une symétrie par rapport à l'axe horizontal de l'image courante. </p>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Renvoie une nouvelle instance de EZImage allouée dynamiquement et qui devra être détruite grâce à l'opérateur delete ou nullptr en cas d’erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a610d4dfd7c4d2ad42d6b25e5ff47ab"></a><!-- doxytag: member="final::paint" ref="a3a610d4dfd7c4d2ad42d6b25e5ff47ab" args="(EZWindow &amp;win, int x, int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a3a610d4dfd7c4d2ad42d6b25e5ff47ab">final::paint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_z_window.html">EZWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Affiche l'image dans la fenêtre. Si has_alpha est vrai, applique la transparence, c’est-à-dire n’affiche que les pixels opaques. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">win</td><td>la fenêtre où aura lieu le tracé. </td></tr>
    <tr><td class="paramname">x,y</td><td>les coordonnées du coin supérieur gauche de l’image dans la fenêtre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a610d4dfd7c4d2ad42d6b25e5ff47ab"></a><!-- doxytag: member="final::paint" ref="a3a610d4dfd7c4d2ad42d6b25e5ff47ab" args="(EZWindow &amp;win, int x, int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a3a610d4dfd7c4d2ad42d6b25e5ff47ab">final::paint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_z_window.html">EZWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Affiche le pixmap dans la fenêtre. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">win</td><td>la fenêtre où aura lieu le tracé. </td></tr>
    <tr><td class="paramname">x,y</td><td>les coordonnées du coin supérieur gauche du tracé du pixmap dans la fenêtre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebe22646f553cd099aee45754deace05"></a><!-- doxytag: member="final::paintSubimage" ref="aebe22646f553cd099aee45754deace05" args="(EZWindow &amp;win, int x, int y, int src_x, int src_y, int width, int height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#aebe22646f553cd099aee45754deace05">final::paintSubimage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_z_window.html">EZWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Trace une partie rectangulaire de l'image courante dans la fenêtre. Si has_alpha est vrai, applique la transparence, c’est-à-dire n’affiche que les pixels opaques. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">win</td><td>la fenêtre où aura lieu le tracé. </td></tr>
    <tr><td class="paramname">x,y</td><td>les coordonnées du coin supérieur gauche de l’image dans la fenêtre. </td></tr>
    <tr><td class="paramname">src_x,src_y</td><td>le point du coin supérieur-gauche de la sous-image à extraire. </td></tr>
    <tr><td class="paramname">width,height</td><td>les dimensions largeur et hauteur de la sous-image à extraire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a404f95ce3eca200baf5c6cfe741888c5"></a><!-- doxytag: member="final::rotate" ref="a404f95ce3eca200baf5c6cfe741888c5" args="(double theta, int quality) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EZImage* <a class="el" href="classfinal.html#a404f95ce3eca200baf5c6cfe741888c5">final::rotate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construit une nouvelle image à partir d'une rotation de l’image courante. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>l'angle de rotation en degrés. </td></tr>
    <tr><td class="paramname">quality</td><td>Si quality = 1, l’algorithme utilisé lisse le résultat (avec une interpolation bilinéaire) ; si quality = 0, l’algorithme privilégie la rapidité (avec un calcul de plus proche voisin), ce qui permet de gagner environ un facteur 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Une nouvelle instance de EZImage allouée dynamiquement (et qui devra être détruite grâce à l'opérateur delete) ou nullptr en cas d’erreur. La taille de l'image est ajustée pour contenir le résultat. Dans l’image résultat, le champ has_alpha est mis à 1, et les parties ne provenant pas de l’image source sont transparentes ; le but est qu’elles n’apparaissent pas lors de l’affichage. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Le résultat étant indépendant du centre de rotation, il n’est pas demandé en paramètre. </dd></dl>
<dl class="see"><dt><b>Voir également:</b></dt><dd>void <a class="el" href="classfinal.html#a9bfac82a791b0bc88094814bd59e204f">rotatePoint(double theta, int src_x, int src_y,int&amp; dst_x, int&amp; dst_y)</a>; </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>L’exemple demo++16 illustre les rotations, sans ou avec transparence. Le centre de rotation (croix rouge) est déplaçable avec les flèches. On peut aussi modifier la qualité. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bfac82a791b0bc88094814bd59e204f"></a><!-- doxytag: member="final::rotatePoint" ref="a9bfac82a791b0bc88094814bd59e204f" args="(double theta, int src_x, int src_y, int &amp;dst_x, int &amp;dst_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a9bfac82a791b0bc88094814bd59e204f">final::rotatePoint</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dst_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dst_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calcule pour un point de coordonnées src_x,src_y dans l’image source, les nouvelles coordonnées dst_x,dst_y du point correspondant dans l’image résultat. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>l'angle de rotation en degrés. </td></tr>
    <tr><td class="paramname">src_x,src_y</td><td>les coordonnées du point dans l'image de départ. </td></tr>
    <tr><td class="paramname">dst_x,dst_y</td><td>les coordonnées du point dans l'image d'arrivée. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Le résultat est obtenu via les paramètres dst_x et dst_y (passés par référence). </dd></dl>
<dl class="see"><dt><b>Voir également:</b></dt><dd>EZImage* EZImage::rotate(double theta,int quality) const  </dd></dl>

</div>
</div>
<a class="anchor" id="a2f4fe23e6f1a1283c38b8b5e7a93dbc6"></a><!-- doxytag: member="final::scale" ref="a2f4fe23e6f1a1283c38b8b5e7a93dbc6" args="(double factor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EZImage* <a class="el" href="classfinal.html#a2f4fe23e6f1a1283c38b8b5e7a93dbc6">final::scale</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construit une nouvelle image par une mise à l'échelle (zoom). </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Le facteur de zoom permet d'indiquer le rapport entre la taille d'arrivée et celle de départ. Ainsi, un facteur de 0.25 indique que la nouvelle image sera quatre fois plus petite que l'image de départ. Pour un facteur de 3, la nouvelle image est 3 fois plus grande que l'image initiale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Attention : le facteur ne doit pas être négatif. </dd></dl>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Renvoie une nouvelle instance de EZImage allouée dynamiquement (et qui devra être détruite grâce à l'opérateur delete) ou nullptr en cas d’erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe89de306240059536ee07dc1f8a29e"></a><!-- doxytag: member="final::setAlpha" ref="a2fe89de306240059536ee07dc1f8a29e" args="(bool has_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a2fe89de306240059536ee07dc1f8a29e">final::setAlpha</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Permet d'activer ou désactiver la transparence de l'image courante. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">has_alpha</td><td>La valeur true active la transparence ; la valeur false la désactive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d817ae0dca397d0a1315ab12b38cb11"></a><!-- doxytag: member="final::setOpacity" ref="a9d817ae0dca397d0a1315ab12b38cb11" args="(int opacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a9d817ae0dca397d0a1315ab12b38cb11">final::setOpacity</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Réglage de la transparence, qu'on appelle alpha channel de l'image. </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">opacity</td><td>valeur entre 0 (complètement transparent) et 255 (complètement opaque). Le détail du principe de calcul de transparence est détaillé dans [<a href="https://fr.wikipedia.org/wiki/Alpha_blending">https://fr.wikipedia.org/wiki/Alpha_blending</a>](cette page Wikipédia). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6556cbdbad6164501ba6a116dd9a0b08"></a><!-- doxytag: member="final::tile" ref="a6556cbdbad6164501ba6a116dd9a0b08" args="(EZWindow &amp;win, int x, int y, int width, int height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfinal.html#a6556cbdbad6164501ba6a116dd9a0b08">final::tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_z_window.html">EZWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Affiche le pixmap dans la fenêtre de manière répétitive dans une zone, comme un papier peint, . </p>
<dl class="params"><dt><b>Paramètres:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">win</td><td>la fenêtre où aura lieu le tracé. </td></tr>
    <tr><td class="paramname">x,y</td><td>les coordonnées du coin supérieur gauche du tracé du pixmap dans la fenêtre. </td></tr>
    <tr><td class="paramname">width,height</td><td>la largeur et la hauteur de la zone dans la fenêtre où le pixmap doit être tracé. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a454235329a4b58a9fd2ba33afacf3ba0"></a><!-- doxytag: member="final::verticalSymmetry" ref="a454235329a4b58a9fd2ba33afacf3ba0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EZImage* <a class="el" href="classfinal.html#a454235329a4b58a9fd2ba33afacf3ba0">final::verticalSymmetry</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construit une nouvelle image par une symétrie par rapport à l'axe vertical de l'image courante. </p>
<dl class="return"><dt><b>Renvoie:</b></dt><dd>Renvoie une nouvelle instance de EZImage allouée dynamiquement et qui devra être détruite grâce à l'opérateur delete ou nullptr en cas d’erreur. </dd></dl>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir du fichier suivant :<ul>
<li>/home/travis/build/L0L022/SuperProjetCPP/ez-lib/<a class="el" href="ez-draw_09_09_8hpp_source.html">ez-draw++.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tout</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Fichiers</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Fonctions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Définitions de type</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Énumérations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Valeurs énumérées</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classfinal.html">final</a>      </li>

    <li class="footer">Généré le Jeudi Mai 25 2017 10:45:26 pour Project c++ par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
