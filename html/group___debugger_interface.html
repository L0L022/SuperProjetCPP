<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Project c++: Debugger and debug C Runtime portable interfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Project c++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Projet c ++ 2017 sur les formes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Espaces&#160;de&#160;nommage</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___debugger_interface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tout</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Espaces de nommage</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Fichiers</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Fonctions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Définitions de type</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Énumérations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Valeurs énumérées</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groupes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Définitions de type</a> &#124;
<a href="#func-members">Fonctions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Debugger and debug C Runtime portable interfaces</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1debug_1_1dbg__startup__info.html">boost::debug::dbg_startup_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of data, which is used by debugger starter routine.  <a href="structboost_1_1debug_1_1dbg__startup__info.html#details">Plus de détails...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Définitions de type</h2></td></tr>
<tr class="memitem:ga72ba6330d8545b09d9dc0867e4beaf7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72ba6330d8545b09d9dc0867e4beaf7f"></a>
typedef boost::function&lt; void(dbg_startup_info <br class="typebreak"/>
const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga72ba6330d8545b09d9dc0867e4beaf7f">boost::debug::dbg_starter</a></td></tr>
<tr class="memdesc:ga72ba6330d8545b09d9dc0867e4beaf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of debugger starter routine. Takes an instance of dbg_startup_into as only argument. <br/></td></tr>
<tr class="separator:ga72ba6330d8545b09d9dc0867e4beaf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:ga6a6cbdda5208baded9dab1ca77925599"><td class="memItemLeft" align="right" valign="top">bool BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga6a6cbdda5208baded9dab1ca77925599">boost::debug::under_debugger</a> ()</td></tr>
<tr class="memdesc:ga6a6cbdda5208baded9dab1ca77925599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if programs runs under debugger.  <a href="#ga6a6cbdda5208baded9dab1ca77925599">Plus de détails...</a><br/></td></tr>
<tr class="separator:ga6a6cbdda5208baded9dab1ca77925599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e86a3fe5eed8e7443b42afe4fb9302d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e86a3fe5eed8e7443b42afe4fb9302d"></a>
void BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga6e86a3fe5eed8e7443b42afe4fb9302d">boost::debug::debugger_break</a> ()</td></tr>
<tr class="memdesc:ga6e86a3fe5eed8e7443b42afe4fb9302d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause program to break execution in debugger at call point. <br/></td></tr>
<tr class="separator:ga6e86a3fe5eed8e7443b42afe4fb9302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d5cee654ae3ac6cf8781e3fe9e0cd3"><td class="memItemLeft" align="right" valign="top">std::string BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga81d5cee654ae3ac6cf8781e3fe9e0cd3">boost::debug::set_debugger</a> (unit_test::const_string dbg_id, dbg_starter s=dbg_starter())</td></tr>
<tr class="memdesc:ga81d5cee654ae3ac6cf8781e3fe9e0cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which debugger to use when attaching and optionally what routine to use to start that debugger.  <a href="#ga81d5cee654ae3ac6cf8781e3fe9e0cd3">Plus de détails...</a><br/></td></tr>
<tr class="separator:ga81d5cee654ae3ac6cf8781e3fe9e0cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f59cddab7c8ffe11698d5cd733319c4"><td class="memItemLeft" align="right" valign="top">bool BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga4f59cddab7c8ffe11698d5cd733319c4">boost::debug::attach_debugger</a> (bool break_or_continue=true)</td></tr>
<tr class="memdesc:ga4f59cddab7c8ffe11698d5cd733319c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches debugger to the current process.  <a href="#ga4f59cddab7c8ffe11698d5cd733319c4">Plus de détails...</a><br/></td></tr>
<tr class="separator:ga4f59cddab7c8ffe11698d5cd733319c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d26be2e424862ec0afd4e9083aaab30"><td class="memItemLeft" align="right" valign="top">void BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga0d26be2e424862ec0afd4e9083aaab30">boost::debug::detect_memory_leaks</a> (bool on_off, unit_test::const_string report_file=unit_test::const_string())</td></tr>
<tr class="memdesc:ga0d26be2e424862ec0afd4e9083aaab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches on/off memory leaks detection.  <a href="#ga0d26be2e424862ec0afd4e9083aaab30">Plus de détails...</a><br/></td></tr>
<tr class="separator:ga0d26be2e424862ec0afd4e9083aaab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4a969d2705dacc26d9ecd87f50e957"><td class="memItemLeft" align="right" valign="top">void BOOST_TEST_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#gaaf4a969d2705dacc26d9ecd87f50e957">boost::debug::break_memory_alloc</a> (long mem_alloc_order_num)</td></tr>
<tr class="memdesc:gaaf4a969d2705dacc26d9ecd87f50e957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes program to break execution in debugger at specific allocation point.  <a href="#gaaf4a969d2705dacc26d9ecd87f50e957">Plus de détails...</a><br/></td></tr>
<tr class="separator:gaaf4a969d2705dacc26d9ecd87f50e957"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga72c7db1c089da9d20991c83202495922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72c7db1c089da9d20991c83202495922"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga72c7db1c089da9d20991c83202495922">boost::debug::dbg_startup_info::pid</a></td></tr>
<tr class="memdesc:ga72c7db1c089da9d20991c83202495922"><td class="mdescLeft">&#160;</td><td class="mdescRight">pid of a program to attach to <br/></td></tr>
<tr class="separator:ga72c7db1c089da9d20991c83202495922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc824363d98941497b99848c4bbc7e66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc824363d98941497b99848c4bbc7e66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#gadc824363d98941497b99848c4bbc7e66">boost::debug::dbg_startup_info::break_or_continue</a></td></tr>
<tr class="memdesc:gadc824363d98941497b99848c4bbc7e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">what to do after debugger is attached <br/></td></tr>
<tr class="separator:gadc824363d98941497b99848c4bbc7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9673000a35ae3e239ec30373a97ebd0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9673000a35ae3e239ec30373a97ebd0f"></a>
unit_test::const_string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga9673000a35ae3e239ec30373a97ebd0f">boost::debug::dbg_startup_info::binary_path</a></td></tr>
<tr class="memdesc:ga9673000a35ae3e239ec30373a97ebd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">path to executable for current process <br/></td></tr>
<tr class="separator:ga9673000a35ae3e239ec30373a97ebd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad433d6f6c31501821c7539530f9871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ad433d6f6c31501821c7539530f9871"></a>
unit_test::const_string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#ga6ad433d6f6c31501821c7539530f9871">boost::debug::dbg_startup_info::display</a></td></tr>
<tr class="memdesc:ga6ad433d6f6c31501821c7539530f9871"><td class="mdescLeft">&#160;</td><td class="mdescRight">if debugger has a GUI, which display to use (on UNIX) <br/></td></tr>
<tr class="separator:ga6ad433d6f6c31501821c7539530f9871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab27f1a1442052ec6ec69739392a2f51f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab27f1a1442052ec6ec69739392a2f51f"></a>
unit_test::const_string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___debugger_interface.html#gab27f1a1442052ec6ec69739392a2f51f">boost::debug::dbg_startup_info::init_done_lock</a></td></tr>
<tr class="memdesc:gab27f1a1442052ec6ec69739392a2f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">path to a uniquely named lock file, which is used to pause current application while debugger is being initialized <br/></td></tr>
<tr class="separator:gab27f1a1442052ec6ec69739392a2f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<p>These interfaces are intended to be used by application to:</p>
<ul>
<li>check if we are running under debugger</li>
<li>attach the debugger to itself</li>
</ul>
<p>Unfortunately these actions differ widely between different debuggers available in a field. These interface present generalized standard form of performing these actions. Implementation depends a lot on the environment application is running in and thus there are several custom implementations supported by the Boost.Test</p>
<p>In addition here you find interfaces for memory leaks detection and reporting.</p>
<p>All these interfaces are defined in namespace <a class="el" href="namespaceboost_1_1debug.html" title="Contains debugger and debug C Runtime interfaces. ">boost::debug</a> </p>
<h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="ga4f59cddab7c8ffe11698d5cd733319c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::debug::attach_debugger </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_or_continue</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches debugger to the current process. </p>
<p>Using currently selected debugger, this routine attempts to attach the debugger to this process. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">break_or_continue</td><td>tells what we wan to do after the debugger is attached. If true - process execution breaks in the point in invocation of this function. Otherwise execution continues, but now it is under the debugger </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>true if debugger successfully attached. False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf4a969d2705dacc26d9ecd87f50e957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::debug::break_memory_alloc </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mem_alloc_order_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes program to break execution in debugger at specific allocation point. </p>
<p>On some platforms/memory managers (at the moment only on Windows/Visual Studio) one can tell a <a class="el" href="struct_c.html">C</a> Runtime to break on specific memory allocation. This can be used in combination with memory leak detection (which reports leaked memory allocation number) to locate the place where leak initiated. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_alloc_order_num</td><td>Specific memory allocation number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d26be2e424862ec0afd4e9083aaab30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::debug::detect_memory_leaks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unit_test::const_string&#160;</td>
          <td class="paramname"><em>report_file</em> = <code>unit_test::const_string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches on/off memory leaks detection. </p>
<p>On platforms where memory leak detection is possible inside of running application (at the moment this is only Windows family) you can switch this feature on and off using this interface. In addition you can specify the name of the file to write a report into. Otherwise the report is going to be generated in standard error stream. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on_off</td><td>boolean switch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">report_file</td><td>file, where the report should be directed to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81d5cee654ae3ac6cf8781e3fe9e0cd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::debug::set_debugger </td>
          <td>(</td>
          <td class="paramtype">unit_test::const_string&#160;</td>
          <td class="paramname"><em>dbg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbg_starter&#160;</td>
          <td class="paramname"><em>s</em> = <code>dbg_starter()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies which debugger to use when attaching and optionally what routine to use to start that debugger. </p>
<p>There are many different debuggers available for different platforms. Some of them also can be used in a different setups/configuratins. For example, gdb can be used in plain text mode, inside ddd, inside (x)emacs or in a separate xterm window. Boost.Test identifies each configuration with unique string. Also different debuggers configurations require different routines which is specifically tailored to start that debugger configuration. Boost.Test comes with set of predefined configuration names and corresponding routines for these configurations:</p>
<ul>
<li>TODO</li>
</ul>
<p>You can use this routine to select which one of the predefined debugger configurations to use in which case you do not need to provide starter routine (the one provided by Boost.Test will be used). You can also use this routine to select your own debugger by providing unique configuration id and starter routine for this configuration.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dbg_id</td><td>Unique id for debugger configuration (for example, gdb) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Optional starter routine for selected configuration (use only you want to define your own configuration) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Id of previously selected debugger configuration </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a6cbdda5208baded9dab1ca77925599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::debug::under_debugger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if programs runs under debugger. </p>
<dl class="section return"><dt>Renvoie</dt><dd>true if current process is under debugger. False otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Généré le Jeudi 25 Mai 2017 16:27:26 pour Project c++ par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
